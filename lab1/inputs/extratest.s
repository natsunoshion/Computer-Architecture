.text
main:
  addi $1, $0, 1 # $1 = 1  
  addi $2, $0, 2 # $2 = 2
  slti $3, $1, 5 # $3 = 1, $1 < 5
  bne $3, $0, L2 # 跳转执行,因为$3!=0

L1:
  addi $1, $1, 3 # 第一次$1 = 4,第二次$1 = 7
  sltiu $4, $1, 5 # 第一次$4 = 1, $1 unsigned < 5,第二次$4 = 0, $1 unsigned >= 5
  beq $4, $0, L3 # 第一次不跳转执行,因为$4==1,第二次跳转执行,因为$4==0

L2:
  andi $5, $1, 2 # 第一次第二次都相当于$5 = 0, $1和2按位与($1第一次为1,第二次为4)
  beq $5, $0, L1 # 第一次第二次都跳转执行,因为$5==0 

L3:
  ori $6, $1, 1 # $6 = 7, $1和1按位或
  xor $7, $6, $1 # $7 = 0, $6和$1按位异或
  bne $7, $0, L5 # 不跳转执行,因为$7==0

L4:
  lui $2, 0x1000 # 设置基址
  lui $8, 0x1234 # $8 = 0x12340000
  li $9, 0x13 # $9 = 0x13,li是伪指令
  li $10, 0x14 # $10 = 0x14
  li $12, 0x12 # $12 = 0x12
  sb $9, 1($2) # 存储字节
  sh $10, 2($2) # 存储半字
  sw $12, 4($2) # 存储字
  lb $9, 1($2) # 加载字节
  lbu $11, 1($2) # 无符号加载字节
  lh $10, 2($2) # 加载半字  
  lhu $13, 2($2) # 无符号加载半字
  lw $12, 4($2) # 加载字
  bltzal $1, L5 # 如果$1<0调用L5
  addi $1, $1, 1 # $1加1

L5: 
  jal L6 # 跳转连接调用L6
  li $v0, 10 # $v0 = 10
  syscall

L6:
  mult $1, $2 # 乘法,$1 = 8
  mflo $3 # 取乘法结果
  mfhi $4 # 取乘法高位结果
  div $3, $1 # 除法
  mflo $5 # 取除法结果
  add $6, $1, $2 # 加法
  addu $7, $1, $2 # 无溢出加法
  sub $8, $1, $2 # 减法
  subu $9, $1, $2 # 无溢出减法
  sllv $10, $1, $2 # 逻辑左移变址
  srlv $11, $1, $2 # 逻辑右移变址
  srav $13, $1, $2 # 算术右移变址
  sll $12, $1, 10 # 逻辑左移立即数
  srl $15, $1, 5 # 逻辑右移立即数
  sra $16, $1, 3 # 算术右移立即数
  and $17, $1, $2 # 按位与
  or $18, $1, $2 # 按位或
  xor $19, $1, $2 # 按位异或
  nor $19, $1, $2 # 按位或非
  slt $19, $1, $2 # 设置小于
  sltu $19, $1, $2 # 无符号设置小于
  multu $1, $2 # 无符号乘法
  divu $1, $2 # 无符号除法  
  xori $1, $1, 1 # $1和1按位异或立即数
  mthi $3 # 设置乘法高位寄存器
  mtlo $4 # 设置乘法低位寄存器

L7:
  addiu $3, $31, 0 # 保存此前$31的值
  bgez $1, L9 # 跳转执行,因为$1 >= 0

L8: 
  bgezal $1, L8 # 如果$1 >= 0,跳转链接执行

L9:
  blez $1, L10 # 如果$1 <= 0,跳转执行
  addiu $1, $1, -1 # $1 -= 1
  j L9 # 跳转至L9,循环

L10:
  bgtz $1, L12 # 不跳转执行,因为$1 = 0

L11: 
  bltz $1, L10 # 不跳转执行,因为$1 = 0

L12:
  la $2, L13 # 将L13地址加载到$2,这是一个伪指令
  jalr $2 # 跳转寄存器链接

L13:
  addiu $31, $3, 0 # 还原$31 
  jr $31 # 返回